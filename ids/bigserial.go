package ids

import (
	"context"

	"github.com/jackc/pgx/v5/pgxpool"
)

// BigSerialGenerator generates BigSerial IDs
// ... existing code ...

type BigSerialGenerator struct{}

func NewBigSerialGenerator() BigSerialGenerator {
	return BigSerialGenerator{}
}

func (g BigSerialGenerator) Generate() string {
	// BigSerial is typically generated by the database, so this might return an empty string or a placeholder.
	return ""
}

func (g BigSerialGenerator) CreateTable(pool *pgxpool.Pool) error {
	_, err := pool.Exec(context.Background(), "CREATE TABLE IF NOT EXISTS bigserial_table (id BIGSERIAL PRIMARY KEY, n BIGINT NOT NULL)")
	return err
}

func (g BigSerialGenerator) DropTable(pool *pgxpool.Pool) error {
	_, err := pool.Exec(context.Background(), "DROP TABLE IF EXISTS bigserial_table")
	return err
}

func (g BigSerialGenerator) InsertRecords(pool *pgxpool.Pool, count int64) error {
	for i := int64(0); i < count; i++ {
		_, err := pool.Exec(context.Background(), "INSERT INTO bigserial_table DEFAULT VALUES")
		if err != nil {
			return err
		}
	}
	return nil
}

func (g BigSerialGenerator) BulkWriteRecords(pool *pgxpool.Pool, count int64) error {
	_, err := pool.Exec(context.Background(), "INSERT INTO bigserial_table (n) SELECT g.n FROM generate_series(1, $1) AS g(n)", count)
	return err
}

func (g BigSerialGenerator) CollectStats(pool *pgxpool.Pool) (map[string]any, error) {
	stats := make(map[string]any)
	var totalTableSize, dataSize, indexSize string
	err := pool.QueryRow(context.Background(), statsQuery, "bigserial_table").Scan(&totalTableSize, &dataSize, &indexSize)
	if err != nil {
		return nil, err
	}
	stats["total_table_size"] = totalTableSize
	stats["data_size"] = dataSize
	stats["index_size"] = indexSize
	return stats, nil
}
